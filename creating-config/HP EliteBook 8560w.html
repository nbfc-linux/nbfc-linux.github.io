<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Example: HP EliteBook 8560w</title>
  <link rel="stylesheet" href="../style.css" />
</head>
<body>
  <header>
    <h1>Example: HP EliteBook 8560w</h1>
  </header>

  <main>
    <section id="note">
      <h2>Note</h2>

      <p>
        This configuration was not written by me, and I do not fully understand the <b>STMM</b> method.
        The following documentation was included for completeness and reference purposes.
      </p>
    </section>

    <section id="analyze">
      <h2>Analyzing the DSDT DSL</h2>

      <p>
        By looking at the
        <a href="https://github.com/nbfc-linux/configs/blob/main/DSDT/HP%20EliteBook%208560w.dsl">DSL file</a>,
        we find the following methods:
      </p>

      <ul>
        <li><b>GFRM</b> (<i>GetFanRPM?</i>) which accesses <b>FRDC</b></li>
        <li><b>STMM</b> (<i>SetThermalStatus</i>) which modifies <b>FTGC</b>, <b>CRZN</b> and <b>TEMP</b></li>
      </ul>

      <pre>
        Method (GFRM, 0, Serialized)
        {
            Local0 = 0x00
            If (\_SB.PCI0.LPCB.EC0.ECRG)
            {
                Acquire (\_SB.PCI0.LPCB.EC0.ECMX, 0xFFFF)
                Local0 = <b>\_SB.PCI0.LPCB.EC0.FRDC</b>
                Release (\_SB.PCI0.LPCB.EC0.ECMX)
                If (Local0)
                {
                    Local1 = (Local0 &gt;&gt; 0x01)
                    Local2 = (0x0003C000 + Local1)
                    Divide (Local2, Local0, Local1, Local0)
                }
            }

            Return (Local0)
        }

        [...]

        Method (STMM, 1, NotSerialized)
        {
            Debug = "SetThermalStatus"
            CreateByteField (Arg0, 0x00, IDTA)
            If (((IDTA &gt;= 0x10) &amp;&amp; (IDTA &lt;= 0x15)))
            {
                \_SB.SSMI (0xEA75, 0x02, 0x28, 0x574D4953, 0x00)
                Return (WFDA ())
            }

            Local0 = Package (0x02)
                {
                    0x00, 
                    0x00
                }
            If (((IDTA &gt;= 0x20) &amp;&amp; (IDTA &lt;= 0x24)))
            {
                Local7 = (IDTA - 0x20)
                Local1 = DerefOf (Arg0 [0x01])
                Local2 = DerefOf (Arg0 [0x02])
                If ((Local1 != DerefOf (THCT [Local7])))
                {
                    Return (Package (0x02)
                    {
                        0x06, 
                        0x00
                    })
                }

                If ((Local1 == 0x00))
                {
                    Return (Local0)
                }

                If (\_SB.PCI0.LPCB.EC0.ECRG)
                {
                    Acquire (\_SB.PCI0.LPCB.EC0.ECMX, 0xFFFF)
                    If (((Local7 &lt; 0x03) || (Local7 == 0x04)))
                    {
                        <b>\_SB.PCI0.LPCB.EC0.CRZN</b> = (0x01 + Local7)
                        If ((Local2 == 0xFF))
                        {
                            Local2 = 0x00
                        }

                        <b>\_SB.PCI0.LPCB.EC0.TEMP</b> = Local2
                        If ((Local7 == 0x02))
                        {
                            Local2 = DerefOf (Arg0 [0x03])
                            <b>\_SB.PCI0.LPCB.EC0.CRZN</b> = 0x04
                            If ((Local2 == 0xFF))
                            {
                                Local2 = 0x00
                            }

                            <b>\_SB.PCI0.LPCB.EC0.TEMP</b> = Local2
                        }
                    }
                    Else
                    {
                        If ((Local2 != 0xFF))
                        {
                            Local2 = \_TZ.CTCT (Local2)
                        }

                        <b>\_SB.PCI0.LPCB.EC0.FTGC</b> = Local2
                    }

                    Release (\_SB.PCI0.LPCB.EC0.ECMX)
                }

                Local6 = 0x00
                While ((Local6 &lt; Local1))
                {
                    DerefOf (TSTV [Local7]) [Local6] = DerefOf (Arg0 [
                        (Local6 + 0x02)])
                    Local6++
                }

                TSTM = 0x01
                Return (Local0)
            }

            If ((IDTA == 0xAA))
            {
                Local1 = 0x00
                While ((Local1 &lt; SizeOf (TSTV)))
                {
                    Local2 = 0x00
                    Local3 = DerefOf (THCT [Local1])
                    While ((Local2 &lt; Local3))
                    {
                        DerefOf (TSTV [Local1]) [Local2] = 0xFF
                        Local2++
                    }

                    Local1++
                }

                If (\_SB.PCI0.LPCB.EC0.ECRG)
                {
                    Acquire (\_SB.PCI0.LPCB.EC0.ECMX, 0xFFFF)
                    Local1 = 0x01
                    While ((Local1 &lt;= 0x05))
                    {
                        <b>\_SB.PCI0.LPCB.EC0.CRZN</b> = Local1
                        <b>\_SB.PCI0.LPCB.EC0.TEMP</b> = 0x00
                        Local1++
                    }

                    <b>\_SB.PCI0.LPCB.EC0.FTGC</b> = 0xFF
                    Release (\_SB.PCI0.LPCB.EC0.ECMX)
                }

                TSTM = 0x00
                Return (Local0)
            }

            Return (Package (0x02)
            {
                0x06, 
                0x00
            })
        }</pre>
    </section>

    <section id="calculate">
      <h2>Calculating Register Addresses</h2>

      <p>
        We again have a look at the DSL file:
      </p>

      <pre>
        OperationRegion (ECRM, EmbeddedControl, 0x00, 0xFF)
        Field (ECRM, ByteAcc, NoLock, Preserve)
        {
            [...]
            Offset (0x22), 
            <b>CRZN</b>,   8, 
            THTA,   8, 
            HYST,   8, 
            CRIT,   8, 
            <b>TEMP</b>,   8, 
            TENA,   8, 
            Offset (0x29), 
            TOAD,   8, 
            PHTP,   8, 
            THEM,   8, 
            TMPO,   8, 
            Offset (0x2E), 
            <b>FRDC</b>,   8, 
            <b>FTGC</b>,   8, 
            [...]
        }</pre>

      <p>
        We calculate the register addresses as follows:
      </p>

      <ul>
        <li><b>FRDC</b> = Offset(0x2E) = 46</li>
        <li><b>FTGC</b> = Offset(0x2E) + (8 / 8) = 0x2F = 47</li>
        <li><b>CRZN</b> = Offset(0x22) = 34</li>
        <li><b>TEMP</b> = Offset(0x22) + ((8 + 8 + 8 + 8) / 8) = 38</li>
      </ul>
    </section>

    <section id="finding-read-values">
      <h2>Finding the ReadRegister Values</h2>

      <p>
        We ensure that the fan is turned off (or at least at the minimum speed).
      </p>

      <pre>sudo ec_probe read 46</pre>

      <p> <i>Output:</i> 100 </p>

      <p>
        We run <code>stress -c 8</code> to stress the system and spin up the fan.
      </p>

      <pre>sudo ec_probe read 46</pre>

      <p> <i>Output:</i> 50 </p>

      <p>Result: <i>100</i> is the <b>MinSpeedValue</b> and <i>50</i> is the <b>MaxSpeedValue</b></p>
    </section>

    <section id="finding-write-values">
      <h2>Finding the WriteRegister Values</h2>

      <p>
        We assume that the values used by <b>ReadRegister</b> correspond to those used by <b>WriteRegister</b>:
      </p>

      <pre>sudo ec_probe write 47 50</pre>
      <pre>sudo ec_probe write 47 100</pre>
      <pre>sudo ec_probe write 47 255</pre>

      <p>
        We see that:
      </p>

      <ul>
        <li><i>50</i> sets the fan to maximum speed</li>
        <li><i>100</i> sets the fan to minimum speed</li>
        <li><i>255</i> resets the fan</li>
      </ul>
    </section>

    <section id="writing-configuration">
      <h2>Writing the Configuration File</h2>

      <ul>
        <li><i>46</i> (<b>FRDC</b>) is the <i>ReadRegister</i></li>
        <li><i>47</i> (<b>FTGC</b>) is the <i>WriteRegister</i></li>
        <li><i>100</i> is the <i>MinSpeedValue</i></li>
        <li><i>50</i> is the <i>MaxSpeedValue</i></li>
        <li><i>255</i> is the <i>FanSpeedResetValue</i></li>
        <li><i>IndependentReadMinMaxValues</i> is <b>false</b>, since <b>FRDC</b> and <b>FTGC</b> share the same range</li>
      </ul>

      <p>The configuration for <b>RegisterWriteConfigurations</b> is as follows (I did not fully understand how these values were derived).</p>

      <ul>
        <li>Register <i>34</i> (<b>CRZN</b>) must be set to <i>1</i></li>
        <li>Register <i>38</i> (<b>TEMP</b>) must be set to <i>28</i></li>
      </ul>

      <p>
        See the configuration file on <a href="https://github.com/nbfc-linux/configs/blob/main/1.0/configs/HP%20EliteBook%208560w.json">GitHub</a>
      </p>
    </section>
  </main>

  <!--
    {
      "FRDC": {"type": "register", "mode": "read" },
      "FTGC": {"type": "register", "mode": "write" },
      "CRZN": {"type": "register", "mode": "misc" },
      "TEMP": {"type": "register", "mode": "misc" }
    }
  -->

  <footer>
    &copy; 2025-2026 NBFC-Linux. Open Source under the GPL 3 License.
  </footer>
</body>
</html>
